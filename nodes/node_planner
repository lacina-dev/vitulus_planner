#!/usr/bin/env python
import rospy
import time
from std_msgs.msg import Bool, String
import sys
import signal
import shapely
from shapely import geometry
from shapely import affinity
from shapely import ops
import random
from geometry_msgs.msg import Pose, Point, Quaternion, PoseStamped, PoseArray, PoseWithCovarianceStamped
from std_msgs.msg import Int16, String, Bool
import numpy as np
import cv2
from nav_msgs.msg import OccupancyGrid
import time
import PyKDL as kdl
import sys
from nav_msgs.msg import Odometry, Path
from geometry_msgs.msg import PolygonStamped, Polygon, Point32
from vitulus_msgs.msg import MapEditPolygon, MapEditPolygonList, MapEditZone, MapEditZoneList, MapEditMap
from visualization_msgs.msg import Marker, MarkerArray
import math
import pickle
import resource
import sys
import geopandas as gpd
import matplotlib.pyplot as plt

np.set_printoptions(threshold=sys.maxsize)


class MapSpec:
    ROBOT_RADIUS = 0.3
    COVERAGE_DIAMETER = 0.25
    OBSTACLE_RESERVE = 0.1
    FILL_HOLE = 2

    UNKNOWN = -1
    FREE = 0
    OBSTACLE = 100
    BORDER_PATH = 120
    NOTHING = -120


class PathPolygon:
    def __init__(self, polygon, path_level):
        self.polygon = polygon
        self.path_level = path_level


class Zone:
    def __init__(self, np_zone, np_zone_navi, msg=MapEditZone()):
        self.msg = msg
        self.np_zone = np.copy(np_zone)
        self.np_zone_navi = np.copy(np_zone_navi)
        self.np_zone_paths = np.copy(np_zone)
        self.path_polygons = []


class MapData:
    def __init__(self, np_map, map_msg=OccupancyGrid()):
        self.name = "map"
        self.initial_map = map_msg
        self.polygon_msgs = []
        self.zones = []
        self.resolution = self.initial_map.info.resolution
        self.origin_x = self.initial_map.info.origin.position.x
        self.origin_y = self.initial_map.info.origin.position.y
        self.position_rc = [self.initial_map.info.width / 2, self.initial_map.info.height / 2]
        self.x_origin = -1 * int(self.initial_map.info.origin.position.x / self.resolution)
        self.y_origin = -1 * int(self.initial_map.info.origin.position.y / self.resolution)
        self.width, self.height = np.shape(np_map)
        self.coverage_distance_px = int(round(((MapSpec.COVERAGE_DIAMETER / 2.0) + MapSpec.OBSTACLE_RESERVE) / self.resolution))
        self.obstacle_margin = MapSpec.ROBOT_RADIUS
        self.obstacle_margin_px = int(round(MapSpec.ROBOT_RADIUS / self.resolution))
        self.fill_hole_px = MapSpec.FILL_HOLE
        self.fill_shape = 'ellipse'
        self.fill_shape_cv = cv2.MORPH_ELLIPSE
        self.np_original = np.copy(np_map)
        self.np_unk = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_free = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_free_filled = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_occupied = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_unk_cleaned = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_obstacle_margin = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_assembled = np.full_like(np_map, fill_value=MapSpec.FREE, dtype=np.int8)
        self.np_semi_assembled = np.full_like(np_map, fill_value=MapSpec.FREE, dtype=np.int8)
        self.np_poly_obstacle = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_poly_free = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)

    def clear_layers(self):
        self.np_unk = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_free = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_free_filled = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_occupied = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_unk_cleaned = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_obstacle_margin = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_assembled = np.full_like(self.np_original, fill_value=MapSpec.FREE, dtype=np.int8)
        self.np_semi_assembled = np.full_like(self.np_original, fill_value=MapSpec.FREE, dtype=np.int8)
        self.np_poly_obstacle = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_poly_free = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)


class Node:

    def __init__(self):
        self.map_data = None
        self.np_show = None
        self.current_zone = None

        self.log_pub = rospy.Publisher("log", String, queue_size=1)
        self.reload_sub = rospy.Subscriber("reload", Bool, self.callback_map_reload)
        self.map_sub = rospy.Subscriber("/map", OccupancyGrid, self.callback_map)
        self.map_show_pub = rospy.Publisher("map_show", OccupancyGrid, queue_size=1)
        self.map_assemble_sub = rospy.Subscriber("assemble_map", MapEditMap, self.callback_map_assemble)
        self.map_data_pub = rospy.Publisher("map_data", MapEditMap, queue_size=1)
        self.map_show_map_layer_sub = rospy.Subscriber("show_map_layer", String, self.callback_show_map_layer)
        self.map_save_poly_sub = rospy.Subscriber("save_polygon", MapEditPolygon, self.callback_map_save_poly)
        self.map_remove_poly_sub = rospy.Subscriber("remove_polygon", String, self.callback_map_remove_poly)
        self.map_poly_list_pub = rospy.Publisher("polygon_list", MapEditPolygonList, queue_size=1)
        self.zone_save_sub = rospy.Subscriber("save_zone", MapEditZone, self.callback_map_save_zone)
        self.zone_remove_sub = rospy.Subscriber("remove_zone", String, self.callback_zone_remove)
        self.zone_selected_sub = rospy.Subscriber("selected_zone", String, self.callback_zone_selected)
        self.zone_list_pub = rospy.Publisher("zone_list", MapEditZoneList, queue_size=1)
        self.marker_pub = rospy.Publisher("/zone_outline_polygons", Marker, queue_size=2)

    def cv_show(self, np_arr):
        # plt.imshow(np_arr)
        # plt.show()
        np_result_window = 'RESULT'
        # cv2.namedWindow(np_result_window, cv2.WINDOW_NORMAL)
        cv2.namedWindow(np_result_window, cv2.WINDOW_AUTOSIZE)
        # cv2.resizeWindow(np_result_window, self.map_data.height, self.map_data.width)
        image = np_arr.view(np.uint8)
        cv2.imshow(np_result_window, image)
        cv2.waitKey()

    def callback_map(self, msg):
        self.map_sub.unregister()
        rospy.loginfo("[{}] Map received".format(rospy.get_caller_id()))
        arr = np.array(msg.data, dtype=np.int8)
        arr = arr.reshape((msg.info.height, msg.info.width))
        self.map_data = MapData(np_map=arr, map_msg=msg)
        self.np_show = self.map_data.np_unk
        self.map_data_publisher()
        self.map_poly_list_publisher()
        self.assemble_map()

    def map_show_publisher(self):
        if self.map_data is not None:
            map_msg = OccupancyGrid()
            map_msg.header.stamp = rospy.Time.now()
            map_msg.header.frame_id = "map"
            map_msg.info = self.map_data.initial_map.info
            map_msg.info.width = self.np_show.shape[1]
            map_msg.info.height = self.np_show.shape[0]
            np_arr = self.np_show.reshape((self.np_show.size,))
            map_msg.data = np_arr.tolist()
            self.map_show_pub.publish(map_msg)

    def assemble_map(self):
        self.map_data.clear_layers()
        self.draw_map_polygons()
        # Create basic map layers (unk, free, occupied)
        self.map_data.np_unk = np.where(self.map_data.np_original == MapSpec.UNKNOWN, MapSpec.OBSTACLE, self.map_data.np_unk)
        self.map_data.np_occupied = np.where(self.map_data.np_original == MapSpec.OBSTACLE, MapSpec.OBSTACLE, self.map_data.np_occupied)
        self.map_data.np_free = np.where(self.map_data.np_original == MapSpec.FREE, MapSpec.FREE, self.map_data.np_free)

        # Remove unknown noise
        shape_size = self.map_data.fill_hole_px
        kernel = cv2.getStructuringElement(self.map_data.fill_shape_cv,
                                           (2 * shape_size + 1, 2 * shape_size + 1),
                                           (shape_size, shape_size))
        self.map_data.np_unk_cleaned = cv2.dilate(self.map_data.np_unk.view(np.uint8), kernel, iterations=1)
        shape_size = self.map_data.fill_hole_px + 2
        kernel = cv2.getStructuringElement(self.map_data.fill_shape_cv,
                                           (2 * shape_size + 1, 2 * shape_size + 1),
                                           (shape_size, shape_size))
        self.map_data.np_unk_cleaned = cv2.erode(self.map_data.np_unk_cleaned, kernel, iterations=1)
        self.map_data.np_unk_cleaned = self.map_data.np_unk_cleaned.view(np.int8)


        # Unknown as obstacle
        self.map_data.np_occupied = np.where(self.map_data.np_unk_cleaned == MapSpec.OBSTACLE, self.map_data.np_unk_cleaned, self.map_data.np_occupied)

        # Fill holes in free
        shape_size = self.map_data.fill_hole_px
        kernel = cv2.getStructuringElement(self.map_data.fill_shape_cv,
                                           (2 * shape_size + 1, 2 * shape_size + 1),
                                           (shape_size, shape_size))
        self.map_data.np_free_filled = cv2.erode(self.map_data.np_free.view(np.uint8), kernel, iterations=1)
        self.map_data.np_free_filled = self.map_data.np_free_filled.view(np.int8)

        # Semi assembled map
        self.map_data.np_semi_assembled = np.where(self.map_data.np_free_filled == MapSpec.FREE, MapSpec.FREE, self.map_data.np_semi_assembled)
        self.map_data.np_semi_assembled = np.where(self.map_data.np_occupied == MapSpec.OBSTACLE, MapSpec.OBSTACLE, self.map_data.np_semi_assembled)
        self.map_data.np_semi_assembled = np.where(self.map_data.np_poly_free == MapSpec.FREE, MapSpec.FREE, self.map_data.np_semi_assembled)
        self.map_data.np_semi_assembled = np.where(self.map_data.np_poly_obstacle == MapSpec.OBSTACLE, MapSpec.OBSTACLE, self.map_data.np_semi_assembled)

        # Obstacle margin
        shape_size = self.map_data.obstacle_margin_px
        kernel = cv2.getStructuringElement(self.map_data.fill_shape_cv,
                                           (2 * shape_size + 1, 2 * shape_size + 1),
                                           (shape_size, shape_size))
        self.map_data.np_obstacle_margin = cv2.dilate(self.map_data.np_semi_assembled.view(np.uint8), kernel, iterations=1)
        self.map_data.np_obstacle_margin = self.map_data.np_obstacle_margin.view(np.int8)

        # Assemble map
        self.map_data.np_assembled = np.where(self.map_data.np_obstacle_margin == MapSpec.OBSTACLE, MapSpec.OBSTACLE, self.map_data.np_semi_assembled)

        # Show map
        self.np_show = self.map_data.np_assembled
        self.log_publisher("Map Assembled.")
        rospy.loginfo("[{}] Map assembled.".format(rospy.get_caller_id()))

    def callback_map_assemble(self, msg):
        self.map_data.obstacle_margin = msg.margin
        self.map_data.obstacle_margin_px = int(round(msg.margin / self.map_data.resolution))
        self.map_data.fill_hole_px = msg.fill
        self.map_data.fill_shape = msg.shape
        if msg.shape == 'ellipse':
            self.map_data.fill_shape_cv = cv2.MORPH_ELLIPSE
        if msg.shape == 'square':
            self.map_data.fill_shape_cv = cv2.MORPH_RECT
        self.assemble_map()
        self.map_data_publisher()
        self.map_zone_list_publisher()

    def map_data_publisher(self):
        msg = MapEditMap()
        msg.header.stamp = rospy.Time.now()
        msg.name = self.map_data.name
        msg.fill = self.map_data.fill_hole_px
        msg.margin = self.map_data.obstacle_margin
        msg.shape = self.map_data.fill_shape
        self.map_data_pub.publish(msg)

    def callback_show_map_layer(self, msg):
        rospy.loginfo("[{}] Show map layer: {}".format(rospy.get_caller_id(), msg.data))
        if msg.data == "filled":
            self.np_show = self.map_data.np_free_filled
        elif msg.data == "obstacle_margin":
            self.np_show = self.map_data.np_obstacle_margin
        elif msg.data == "obstacles_poly":
            self.np_show = self.map_data.np_poly_obstacle
        elif msg.data == "free_poly":
            self.np_show = self.map_data.np_poly_free
        elif msg.data == "assembled_lite":
            self.np_show = self.map_data.np_semi_assembled
        elif msg.data == "original":
            self.np_show = self.map_data.np_original
        elif msg.data == "assembled":
            self.np_show = self.map_data.np_assembled
        elif msg.data == "zone_map":
            if self.current_zone is not None:
                self.np_show = self.current_zone.np_zone
        elif msg.data == "zone_border_path":
            if self.current_zone is not None:
                self.np_show = self.current_zone.np_zone_paths
        elif msg.data == "zone_navi":
            if self.current_zone is not None:
                self.np_show = self.current_zone.np_zone_navi

    def callback_map_save_poly(self, msg):
        # Add or overwrite polygon
        poly_exist = False
        poly_exist_id = -1
        i = 0
        for p_msg in self.map_data.polygon_msgs:
            if p_msg.name == msg.name:
                poly_exist = True
                poly_exist_id = i
            i += 1
        if not poly_exist:
            self.map_data.polygon_msgs.append(msg)
        else:
            self.map_data.polygon_msgs[poly_exist_id] = msg
        self.map_poly_list_publisher()
        self.assemble_map()
        self.log_publisher("Polygon {} {} saved.".format(msg.type, msg.name))  # Show map
        self.np_show = self.map_data.np_semi_assembled
        # self.cv_show(self.map_data.np_assembled)

    def draw_map_polygons(self):
        # Draw polygons to layers
        for p_msg in self.map_data.polygon_msgs:
            polygon = []
            for point in p_msg.polygon.polygon.points:
                x_point = int(point.x / self.map_data.resolution)
                y_point = int(point.y / self.map_data.resolution)
                polygon.append([self.map_data.x_origin + x_point, self.map_data.y_origin + y_point])
            np_polygon = np.array(polygon)
            if p_msg.type == 'obstacle':
                cv2.fillPoly(self.map_data.np_poly_obstacle, pts=[np_polygon], color=MapSpec.OBSTACLE)
            if p_msg.type == 'free':
                cv2.fillPoly(self.map_data.np_poly_free, pts=[np_polygon], color=MapSpec.FREE)

    def callback_map_remove_poly(self, msg):
        # Remove polygon
        for p_msg in self.map_data.polygon_msgs:
            if p_msg.name == msg.data:
                self.map_data.polygon_msgs.remove(p_msg)
        self.map_poly_list_publisher()
        self.assemble_map()
        self.log_publisher("Polygon {} removed.".format(msg.data))  # Show map
        self.np_show = self.map_data.np_semi_assembled

    def map_poly_list_publisher(self):
        msg = MapEditPolygonList()
        msg.header.stamp = rospy.Time.now()
        msg.header.frame_id = "map"
        msg.polygon_list = []
        for poly_msg in self.map_data.polygon_msgs:
            msg.polygon_list.append(poly_msg)
        self.map_poly_list_pub.publish(msg)

    def callback_map_save_zone(self, msg):
        polygon = []
        for point in msg.polygon.polygon.points:
            x_point = int(point.x / self.map_data.resolution)
            y_point = int(point.y / self.map_data.resolution)
            polygon.append([self.map_data.x_origin + x_point, self.map_data.y_origin + y_point])
        np_polygon = np.array(polygon)

        # make zone polygon smaller by cut coverage radius
        shape_poly = geometry.Polygon(np_polygon)
        cut_margin_dist = int(round((MapSpec.COVERAGE_DIAMETER / 2) / self.map_data.resolution))
        shape_poly = shape_poly.buffer(-cut_margin_dist)
        pointarray = []
        for point in shape_poly.exterior.coords:
            pointarray.append([int(point[0]), int(point[1])])
        np_polygon_mow = np.array(pointarray)

        # draw polygon on zone layer
        np_zone = np.zeros_like(self.map_data.np_assembled)
        cv2.fillPoly(np_zone, pts=[np_polygon_mow], color=MapSpec.OBSTACLE)
        np_zone = np.where(np_zone == MapSpec.OBSTACLE, self.map_data.np_assembled, MapSpec.OBSTACLE)

        # make zone polygon bigger by obstacle margin and draw zone map for navi
        shape_poly = geometry.Polygon(np_polygon)
        shape_poly = shape_poly.buffer(self.map_data.obstacle_margin_px, cap_style='flat', join_style='mitre')
        pointarray = []
        for point in shape_poly.exterior.coords:
            pointarray.append([int(point[0]), int(point[1])])
        np_polygon_navi = np.array(pointarray)

        # draw polygon on navi zone layer
        np_zone_navi = np.zeros_like(self.map_data.np_assembled)
        cv2.fillPoly(np_zone_navi, pts=[np_polygon_navi], color=MapSpec.OBSTACLE)
        np_zone_navi = np.where(np_zone_navi == MapSpec.OBSTACLE, self.map_data.np_semi_assembled, MapSpec.OBSTACLE)
        zone = Zone(np_zone, np_zone_navi, msg)

        # Create paths around zone and coverage paths
        self.current_zone = zone
        self.create_paths_around()
        self.create_coverage_paths()

        # Save or update current zone
        zone_exist = False
        zone_exist_id = -1
        i = 0
        for z in self.map_data.zones:
            if z.msg.name == msg.name:
                zone_exist = True
                zone_exist_id = i
            i += 1
        if not zone_exist:
            self.map_data.zones.append(self.current_zone)
        else:
            self.map_data.zones[zone_exist_id] = self.current_zone

        self.map_zone_list_publisher()
        # Show zone map
        self.np_show = self.current_zone.np_zone_paths

    def callback_zone_remove(self, msg):
        # Remove zone
        for zone in self.map_data.zones:
            if zone.msg.name == msg.data:
                self.map_data.zones.remove(zone)
        self.map_zone_list_publisher()
        # Show map
        self.np_show = self.map_data.np_assembled
        self.log_publisher("Zone {} removed.".format(msg.data))

    def callback_zone_selected(self, msg):
        if msg.data == "cancel**cancel**":
            self.np_show = self.map_data.np_assembled
            self.current_zone = None
        else:
            for zone in self.map_data.zones:
                if zone.msg.name == msg.data:
                    self.current_zone = zone
                    self.np_show = zone.np_zone
                    self.log_publisher("Zone {} selected.".format(msg.data))
                    break

    def map_zone_list_publisher(self):
        msg = MapEditZoneList()
        msg.header.stamp = rospy.Time.now()
        msg.header.frame_id = "map"
        msg.zone_list = []
        for zone in self.map_data.zones:
            msg.zone_list.append(zone.msg)
        self.zone_list_pub.publish(msg)

    def get_shapely_poly(self, polygons, contours, hierarchy, poly_id, external, internals):
        while poly_id != -1:
            contour = contours[poly_id].squeeze(axis=1)
            if len(contour) >= 3:
                first_child_id = hierarchy[poly_id][2]
                children = [] if external else None
                self.get_shapely_poly(polygons, contours, hierarchy, first_child_id, not external, children)
                if external:
                    polygon = geometry.Polygon(contour, holes=children)
                    polygons.append(polygon)
                else:
                    internals.append(contour)


            poly_id = hierarchy[poly_id][0]

    def create_paths_around(self):
        self.log_publisher("Creating outline paths...")
        image_copy = self.current_zone.np_zone_navi.copy()
        area_sum = 0
        for i in range(0, self.current_zone.msg.border_paths):
            print("i: {}".format(i))
            inverted = cv2.bitwise_not(self.current_zone.np_zone_paths.view(np.uint8))
            inverted = np.where(inverted == 255, inverted, 0)
            contours, hierarchy = cv2.findContours(inverted, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)
            if hierarchy is None:
                break
            polygons = []
            hierarchy = hierarchy[0]
            self.get_shapely_poly(polygons, contours, hierarchy, 0, True, [])
            for poly in polygons:
                ros_poly = self.convert_poly_to_ros_coord(poly)
                self.current_zone.path_polygons.append(PathPolygon(ros_poly, i))

                # Save area of the first path greater of 1/2 of the coverage diameter
                if i == 0:
                    mow_radius = MapSpec.COVERAGE_DIAMETER / 2
                    poly_b = ros_poly.buffer(mow_radius,
                                       join_style='round',
                                       mitre_limit=5.0,
                                       cap_style='flat',
                                       quad_segs=16)
                    area_sum += poly_b.area

                # Draw exterior to map
                points = [[x, y] for x, y in zip(*poly.exterior.coords.xy)]
                image_copy = cv2.polylines(image_copy, pts=np.array([points]).astype(np.int32),
                                           isClosed=True, color=90, thickness=1)

                for inner in poly.interiors:
                    # Draw interior holes to map
                    points = [[x, y] for x, y in zip(*inner.coords.xy)]
                    image_copy = cv2.polylines(image_copy, pts=np.array([points]).astype(np.int32),
                                               isClosed=True, color=120, thickness=1)

            # Obstacle margin
            shape_size = int(round(self.current_zone.msg.paths_distance / self.map_data.resolution))
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,
                                               (2 * shape_size + 1, 2 * shape_size + 1),
                                               (shape_size, shape_size))
            self.current_zone.np_zone_paths = cv2.dilate(self.current_zone.np_zone_paths.view(np.uint8), kernel, iterations=1)
            self.current_zone.np_zone_paths = self.current_zone.np_zone_paths.view(np.int8)
        self.current_zone.np_zone_paths = image_copy
        self.current_zone.msg.area = round(area_sum)

    def map_coord_to_ros_coord(self, points):
        output = []
        for point in points:
            point[0] = point[0] * self.map_data.resolution + self.map_data.origin_x
            point[1] = point[1] * self.map_data.resolution + self.map_data.origin_y
            output.append(point)
        return output


    def convert_poly_to_ros_coord(self, poly):
        points = [[x, y] for x, y in zip(*poly.exterior.coords.xy)]
        ext_coords = self.map_coord_to_ros_coord(points)
        holes = []
        for inner in poly.interiors:
            points2 = [[x, y] for x, y in zip(*inner.coords.xy)]
            in_coords = self.map_coord_to_ros_coord(points2)
            holes.append(in_coords)
        return geometry.Polygon(ext_coords, holes=holes)

    def zone_outline_poly_publisher(self):
        points = []
        zone = self.current_zone
        if zone is not None:
            for poly in zone.path_polygons:
                poly = poly.polygon.simplify(self.current_zone.msg.simplify, preserve_topology=True)
                line_start = None
                for point in shapely.get_coordinates(poly.exterior):
                    if line_start == None:
                        line_start = Point32(point[0], point[1], 0)
                    else:
                        points.append(line_start)
                        points.append(Point32(point[0], point[1], 0))
                        line_start = Point32(point[0], point[1], 0)
                for inner in poly.interiors:
                    line_start = None
                    for point in shapely.get_coordinates(inner):
                        if line_start == None:
                            line_start = Point32(point[0], point[1], 0)
                        else:
                            points.append(line_start)
                            points.append(Point32(point[0], point[1], 0))
                            line_start = Point32(point[0], point[1], 0)

        marker = Marker()
        marker.header.frame_id = "map"
        marker.header.stamp = rospy.Time.now()
        marker.ns = "zone_outline_polys"
        marker.type = Marker.LINE_LIST
        marker.id = 0
        marker.scale.x = 0.03
        marker.scale.y = 0.03
        marker.scale.z = 0.03
        marker.color.r = 0.0
        marker.color.g = 0.0
        marker.color.b = 1.0
        marker.color.a = 1.0
        marker.pose.position.x = 0
        marker.pose.position.y = 0
        marker.pose.position.z = 0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.points = points
        self.marker_pub.publish(marker)

    def get_top_level_outline_poly(self):
        polygons = []
        for poly in self.current_zone.path_polygons:
            if poly.path_level == self.current_zone.msg.border_paths - 1:
                polygons.append(poly.polygon)
        return polygons

    def filter_polygons(self, min_length=0.8, min_area=0.3):
        polygons = []
        for poly in self.current_zone.path_polygons:
            if poly.polygon.length > min_length and poly.polygon.area > min_area:
                polygons.append(poly.polygon)
        return polygons

    def filter_list_of_polygons(self, polygons_in, min_length=0.8, min_area=0.3):
        polygons = []
        for poly in polygons_in:
            # print("poly.length: {}".format(poly.length))
            # print("poly.area: {}".format(poly.area))
            if poly.length > min_length and poly.area > min_area:
                polygons.append(poly)
        return polygons

    def create_coverage_paths(self):
        self.log_publisher("Creating coverage paths...")
        # Prepare outline polygons
        top_level_polygons = self.get_top_level_outline_poly()
        top_level_polygons = self.filter_list_of_polygons(top_level_polygons)

        multilines = []
        angle = self.current_zone.msg.coverage_angle
        paths_distance = self.current_zone.msg.paths_distance
        for polygon in top_level_polygons:
            max_length = 0.5 + shapely.distance(geometry.Point(polygon.bounds[0], polygon.bounds[1]),
                                                geometry.Point(polygon.bounds[2], polygon.bounds[3]))

            # Create lines for coverage
            start = geometry.Point(polygon.bounds[0], polygon.bounds[1], 0.0)
            end = geometry.Point(start.x + max_length, start.y, 0.0)
            line_list = []
            line_count = int(max_length / paths_distance)
            for n in range(0, line_count):
                line = geometry.LineString([start, end])
                line_list.append(line)
                start = geometry.Point(start.x, start.y + paths_distance, 0.0)
                end = geometry.Point(end.x, end.y + paths_distance, 0.0)
            multiline = geometry.MultiLineString(line_list)

            # center with border polygon
            move_x = polygon.centroid.x - multiline.centroid.x
            move_y = polygon.centroid.y - multiline.centroid.y
            multiline = affinity.translate(multiline, xoff=move_x, yoff=move_y, zoff=0)

            # rotate lines
            multiline = affinity.rotate(multiline, angle, origin="center", use_radians=False)

            # cut lines to fit the polygon outer border
            multiline = shapely.ops.split(multiline, polygon.buffer(-0.1))

            # remove lines out of the zone
            line_list = []
            for line in multiline.geoms:
                if shapely.contains_properly(polygon, line):
                    line_list.append(line)
            multiline = geometry.MultiLineString(line_list)

            # Remove short lines
            line_list = []
            for line in multiline.geoms:
                if line.length > 0.15:
                    line_list.append(line)
            multiline = geometry.MultiLineString(line_list)

            # connect lines by nearest point of other lines
            line_list = []
            for line in multiline.geoms:
                line_list.append([[line.coords[0][0], line.coords[0][1]],
                                  [line.coords[1][0], line.coords[1][1]]])
            np_lines = np.array(line_list)
            line_list = []
            x = polygon.bounds[0]
            y = polygon.bounds[3]
            point = geometry.Point(x, y)
            i_all = 0
            # multilines = []
            direction = True  # True: forward, False: backward
            dir_last = None  # True: forward, False: backward
            while True:
                nearest_line = None
                distance = 9999999
                ni = 0
                i_line = 0
                # Find the nearest line from point
                for line in np_lines:
                    begin_point = geometry.Point([line[0][0], line[0][1]])
                    end_point = geometry.Point([line[1][0], line[1][1]])
                    if begin_point.distance(point) < distance:
                        distance = begin_point.distance(point)
                        nearest_line = line
                        direction = True
                        i_line = ni
                    if end_point.distance(point) < distance:
                        distance = end_point.distance(point)
                        nearest_line = [line[1], line[0]]  # reverse line
                        direction = False
                        i_line = ni
                    ni = ni + 1

                # print("*****************************************************")
                if nearest_line is not None:  # if any nearest line available
                    conn_line = geometry.LineString(
                        [[point.x, point.y], [nearest_line[0][0], nearest_line[0][1]]])
                    print("conn_line length: {}".format(conn_line.length))
                    is_cross = self.is_crossing_check(conn_line, polygon)
                    if not is_cross:  # if the line is not crossing, connect
                        line_list.append(conn_line)
                        line_list.append(geometry.LineString(nearest_line))
                    else:  # if the line is crossing, close cell
                        multilines.append(geometry.MultiLineString(line_list))
                        line_list = []
                        line_list.append(geometry.LineString(nearest_line))

                    point = geometry.Point([nearest_line[1][0], nearest_line[1][1]])
                    np_lines = np.delete(np_lines, [i_line], 0)
                    dir_last = direction
                    i_all = i_all + 1

                else:
                    break
                # multilines.append(geometry.MultiLineString(line_list))
            multilines.append(geometry.MultiLineString(line_list))
            multilines += multilines

            # self.current_zone.np_zone_paths = self.draw_multilines(multiline, self.current_zone.np_zone_paths)
        for multiline in multilines:
            self.current_zone.np_zone_paths = self.draw_multilines(multiline, self.current_zone.np_zone_paths)

    def draw_multilines(self, multilines, np_coverage):
        # Draw multilines to map
        for line in multilines.geoms:
            points = [[self.map_data.x_origin + int(x / self.map_data.resolution),
                       self.map_data.y_origin + int(y / self.map_data.resolution)] for x, y in zip(*line.coords.xy)]
            np_coverage = cv2.polylines(np_coverage, pts=np.array([points]).astype(np.int32),
                                        isClosed=True, color=180, thickness=1)
        return np_coverage

    def is_crossing_check(self, geom, polygon):
        result = False
        if not polygon.contains(geom):  # Zone border polygon
            result = True
            print("Line cross border polygon.")
            # self.marker_test(line=geom, polygon=polygon)
            return result
        return result

    def make_coverage_lines(self, angle, line_distance, margin=0.10):
        self.log_publisher("Create coverage paths...")
        max_length = 0.5 + shapely.distance(geometry.Point(self.bounds[0], self.bounds[1]), geometry.Point(self.bounds[2], self.bounds[3]))
        # print("max_length: {}".format(max_length))

        self.multilines = []
        line_distance = line_distance / 100  # cm to m
        # For every border polygon
        print("border_path_poly_list: {}".format(self.border_path_poly_list))
        print("border_path_poly_list len: {}".format(len(self.border_path_poly_list)))
        for i in range(0, len(self.border_path_poly_list)):
            print("i = {}".format(i))


            # Create lines for coverage
            length = max_length

            start = geometry.Point(self.bounds[0], self.bounds[1], 0.0)
            end = geometry.Point(start.x + length, start.y, 0.0)
            line_list = []
            line_count = int(length / line_distance)
            print("line_distance: {}".format(line_distance))
            print("length: {}".format(length))
            print("line_count: {}".format(line_count))
            for n in range(0, line_count):
                line = geometry.LineString([start, end])
                line_list.append(line)
                start = geometry.Point(start.x, start.y + line_distance, 0.0)
                end = geometry.Point(end.x, end.y + line_distance, 0.0)
            multiline = geometry.MultiLineString(line_list)

            # center with border polygon
            # move_x = self.zone_path_poly_list[i].centroid.x - multiline.centroid.x
            # move_y = self.zone_path_poly_list[i].centroid.y - multiline.centroid.y
            move_x = self.poly_of_border_zone.centroid.x - multiline.centroid.x
            move_y = self.poly_of_border_zone.centroid.y - multiline.centroid.y
            multiline = affinity.translate(multiline, xoff=move_x, yoff=move_y, zoff=0)

            # rotate lines
            multiline = affinity.rotate(multiline, angle, origin="center", use_radians=False)


            print("multiline: {}".format(len(multiline.geoms)))

            # cut lines to fit the polygon outer border
            multiline = shapely.ops.split(multiline, self.zone_path_poly_cut_list[i])
            print("multiline - cut lines to fit the polygon outer border: {}".format(len(multiline.geoms)))
            self.show_poly_image(self.zone_path_poly_cut_list[i])
            multi_list = []
            for line in multiline.geoms:
                # print("line: {}".format(line))
                # print("line coords: {}".format(line.coords))
                # print("line: {}".format(line.coords[0][0]))
                xy_line = geometry.LineString([(line.coords[0][0], line.coords[0][1]), (line.coords[1][0], line.coords[1][1])] )
                multi_list.append(xy_line)
            # gdf = gpd.GeoDataFrame(geometry=multi_list)
            # gdf.head()
            # gdf.plot("sssss")
            p = gpd.GeoSeries(multi_list + [self.zone_path_poly_cut_list[i]])
            p.plot()
            plt.show()

            # remove lines out of the zone
            line_list = []
            for line in multiline.geoms:
                if shapely.contains_properly(self.border_path_poly_list[i], line):
                    line_list.append(line)
            multiline = geometry.MultiLineString(line_list)
            print("multiline: {}".format(len(multiline.geoms)))
            self.show_poly_image(self.border_path_poly_list[i])

            # Remove lines in obstacle polygons
            line_list = []
            for line in multiline.geoms:
                hit = False
                for poly in self.obstacle_polygons_obj:
                    if shapely.intersects(poly.buffer(margin - 0.00001), line):
                        hit = True
                if not hit:
                    line_list.append(line)
            multiline = geometry.MultiLineString(line_list)
            print("multiline: {}".format(len(multiline.geoms)))

            # Remove short lines
            line_list = []
            for line in multiline.geoms:
                # print("line: {}".format(line))
                # print("line.length: {}".format(line.length))
                if line.length > 0.15:
                    line_list.append(line)
            multiline = geometry.MultiLineString(line_list)
            print("multiline: {}".format(len(multiline.geoms)))

            self.show_poly_image(self.border_path_poly_list[i])
            # connect lines by nearest point of lines around /////////////////////////////////////////////////
            line_list = []
            for line in multiline.geoms:
                line_list.append([[line.coords[0][0], line.coords[0][1]], [line.coords[1][0], line.coords[1][1]]])
            np_lines = np.array(line_list)

            line_list = []
            x = self.bounds[0]
            y = self.bounds[3]
            point = geometry.Point(x, y)
            i_all = 0
            multilines = []
            direction = True  # True: forward, False: backward
            dir_last = None  # True: forward, False: backward
            while True:
                nearest_line = None
                distance = 9999999
                ni = 0
                i_line = 0
                # Find the nearest line from point
                for line in np_lines:
                    begin_point = geometry.Point([line[0][0], line[0][1]])
                    end_point = geometry.Point([line[1][0], line[1][1]])
                    if begin_point.distance(point) < distance:
                        distance = begin_point.distance(point)
                        nearest_line = line
                        direction = True
                        i_line = ni
                    if end_point.distance(point) < distance:
                        distance = end_point.distance(point)
                        nearest_line = [line[1], line[0]]  # reverse line
                        direction = False
                        i_line = ni
                    ni = ni + 1

                # print("*****************************************************")
                if nearest_line is not None:  # if any nearest line available
                    conn_line = geometry.LineString([[point.x, point.y], [nearest_line[0][0], nearest_line[0][1]]])
                    print("conn_line length: {}".format(conn_line.length))
                    # is_cross = self.is_crossing_multiline(multilines, conn_line, obstacle_polygons_obj, border_path_poly)
                    is_cross = self.is_crossing_check(conn_line, self.obstacle_polygons_obj, self.border_path_poly_list[i])
                    # print("is_cross: {}".format(is_cross))
                    # if 0.0 < conn_line.length and not is_cross and dir_last is not None and dir_last != direction:  # if the line is not crossing, connect
                    if not is_cross:  # if the line is not crossing, connect
                        # print("if the line is not crossing, connect")
                        line_list.append(conn_line)
                        line_list.append(geometry.LineString(nearest_line))
                    else:  # if the line is crossing, close cell
                        # print("if the line is crossing, close cell")
                        multilines.append(geometry.MultiLineString(line_list))
                        line_list = []
                        line_list.append(geometry.LineString(nearest_line))

                    point = geometry.Point([nearest_line[1][0], nearest_line[1][1]])
                    np_lines = np.delete(np_lines, [i_line], 0)
                    dir_last = direction
                    i_all = i_all + 1

                else:
                    break
                # multilines.append(geometry.MultiLineString(line_list))
            multilines.append(geometry.MultiLineString(line_list))
            self.multilines += multilines

    def log_publisher(self, log_txt):
        msg = String()
        msg.data = log_txt
        self.log_pub.publish(msg)

    def callback_map_reload(self, msg):
        self.map_data_publisher()
        self.map_poly_list_publisher()
        self.map_zone_list_publisher()

if __name__ == '__main__':
    try:
        rospy.init_node('vitulus_planner_node')
        rospy.loginfo("[{}] Initialising...".format(rospy.get_caller_id()))
        node = Node()
        r = rospy.Rate(1)  # Hz

        def signal_handler():
            rospy.signal_shutdown("end")
            sys.exit(0)
        signal.signal(signal.SIGINT, signal_handler)

        while not rospy.is_shutdown():
            node.map_show_publisher()
            node.zone_outline_poly_publisher()
            r.sleep()

    except rospy.ROSInterruptException:
        rospy.logerr("[{}] error.".format(rospy.get_caller_id()))
