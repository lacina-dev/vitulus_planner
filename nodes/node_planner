#!/usr/bin/env python
import rospy
import time
from std_msgs.msg import Bool, String
import sys
import os
import signal
import shapely
from shapely import geometry
from shapely import affinity
from shapely import ops
import random
from geometry_msgs.msg import Pose, Point, Quaternion, PoseStamped, PoseArray, PoseWithCovarianceStamped
from std_msgs.msg import Int16, String, Bool
import numpy as np
import cv2
from nav_msgs.msg import OccupancyGrid
import time
import PyKDL as kdl
from nav_msgs.msg import Odometry, Path
from geometry_msgs.msg import PolygonStamped, Polygon, Point32
from vitulus_msgs.msg import MapEditPolygon, MapEditPolygonList, MapEditZone, MapEditZoneList, MapEditMap, PlannerProgramList, PlannerProgram
from visualization_msgs.msg import Marker, MarkerArray
import math
import pickle
import resource
import sys
import geopandas as gpd
import matplotlib.pyplot as plt

np.set_printoptions(threshold=sys.maxsize)


class MapSpec:
    ROBOT_RADIUS = 0.38
    COVERAGE_DIAMETER = 0.29
    OBSTACLE_RESERVE = 0.1
    FILL_HOLE = 2

    UNKNOWN = -1
    FREE = 0
    OBSTACLE = 100
    BORDER_PATH = 120
    NOTHING = -120


class PathPolygon:
    def __init__(self, polygon, path_level):
        self.polygon = polygon
        self.path_level = path_level


class Zone:
    def __init__(self, np_zone, np_zone_navi, msg=MapEditZone()):
        self.msg = msg
        self.np_zone = np.copy(np_zone)
        self.np_zone_navi = np.copy(np_zone_navi)
        self.np_zone_paths = np.copy(np_zone)
        self.path_polygons = []
        self.multilines = []
        self.zone_path_lines_marker_array = MarkerArray()
        self.path_msg_coverage = Path()
        self.path_msg_coverage.header.frame_id = "map"
        self.path_msg_outline = Path()
        self.path_msg_outline.header.frame_id = "map"


class MapData:
    def __init__(self, np_map, map_msg=OccupancyGrid()):
        self.name = "map"
        self.initial_map = map_msg
        self.polygon_msgs = []
        self.zones = []
        self.planner_program_list_msg = None
        self.resolution = self.initial_map.info.resolution
        self.origin_x = self.initial_map.info.origin.position.x
        self.origin_y = self.initial_map.info.origin.position.y
        self.position_rc = [self.initial_map.info.width / 2, self.initial_map.info.height / 2]
        self.x_origin = -1 * int(self.initial_map.info.origin.position.x / self.resolution)
        self.y_origin = -1 * int(self.initial_map.info.origin.position.y / self.resolution)
        self.width, self.height = np.shape(np_map)
        self.coverage_distance_px = int(round(((MapSpec.COVERAGE_DIAMETER / 2.0) + MapSpec.OBSTACLE_RESERVE) / self.resolution))
        self.obstacle_margin = MapSpec.ROBOT_RADIUS
        self.obstacle_margin_px = int(round(MapSpec.ROBOT_RADIUS / self.resolution))
        self.fill_hole_px = MapSpec.FILL_HOLE
        self.fill_shape = 'ellipse'
        self.fill_shape_cv = cv2.MORPH_ELLIPSE
        self.np_original = np.copy(np_map)
        self.np_unk = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_free = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_free_filled = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_occupied = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_unk_cleaned = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_obstacle_margin = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_assembled = np.full_like(np_map, fill_value=MapSpec.FREE, dtype=np.int8)
        self.np_semi_assembled = np.full_like(np_map, fill_value=MapSpec.FREE, dtype=np.int8)
        self.np_poly_obstacle = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_poly_free = np.full_like(np_map, fill_value=MapSpec.NOTHING, dtype=np.int8)

    def clear_layers(self):
        self.np_unk = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_free = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_free_filled = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_occupied = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_unk_cleaned = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_obstacle_margin = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_assembled = np.full_like(self.np_original, fill_value=MapSpec.FREE, dtype=np.int8)
        self.np_semi_assembled = np.full_like(self.np_original, fill_value=MapSpec.FREE, dtype=np.int8)
        self.np_poly_obstacle = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)
        self.np_poly_free = np.full_like(self.np_original, fill_value=MapSpec.NOTHING, dtype=np.int8)


class Node:

    def __init__(self):
        self.map_data = None
        self.np_show = None
        self.current_zone = None
        self.data_loaded = None
        self.program_active = None

        self.log_pub = rospy.Publisher("log", String, queue_size=1)
        self.reload_sub = rospy.Subscriber("reload", Bool, self.callback_map_reload)
        self.map_sub = rospy.Subscriber("/map", OccupancyGrid, self.callback_map)
        self.map_show_pub = rospy.Publisher("map_show", OccupancyGrid, queue_size=1)
        self.map_assemble_sub = rospy.Subscriber("assemble_map", MapEditMap, self.callback_map_assemble)
        self.map_data_pub = rospy.Publisher("map_data", MapEditMap, queue_size=1)
        self.map_show_map_layer_sub = rospy.Subscriber("show_map_layer", String, self.callback_show_map_layer)
        self.map_save_poly_sub = rospy.Subscriber("save_polygon", MapEditPolygon, self.callback_map_save_poly)
        self.map_remove_poly_sub = rospy.Subscriber("remove_polygon", String, self.callback_map_remove_poly)
        self.map_poly_list_pub = rospy.Publisher("polygon_list", MapEditPolygonList, queue_size=1)
        self.zone_save_sub = rospy.Subscriber("save_zone", MapEditZone, self.callback_map_save_zone)
        self.zone_remove_sub = rospy.Subscriber("remove_zone", String, self.callback_zone_remove)
        self.zone_selected_sub = rospy.Subscriber("selected_zone", String, self.callback_zone_selected)
        self.zone_list_pub = rospy.Publisher("zone_list", MapEditZoneList, queue_size=1)
        self.marker_pub = rospy.Publisher("zone_outline_polygons", Marker, queue_size=1)
        self.marker_zone_path_lines_pub = rospy.Publisher("/zone_path_lines", MarkerArray, queue_size=0)
        self.coverage_path_pub = rospy.Publisher("coverage_path", Path, queue_size=1)
        self.outline_path_pub = rospy.Publisher("outline_path", Path, queue_size=1)
        self.map_assembled_pub = rospy.Publisher("map_assembled", OccupancyGrid, queue_size=1)
        self.map_edited_pub = rospy.Publisher("map_edited", OccupancyGrid, queue_size=1)
        self.program_list_pub = rospy.Publisher("program_list", PlannerProgramList, queue_size=1)
        self.program_active_pub = rospy.Publisher("program_active", PlannerProgram, queue_size=1)
        self.program_select_sub = rospy.Subscriber("program_select", String, self.callback_program_select)

    def cv_show(self, np_arr):
        # plt.imshow(np_arr)
        # plt.show()
        np_result_window = 'RESULT'
        # cv2.namedWindow(np_result_window, cv2.WINDOW_NORMAL)
        cv2.namedWindow(np_result_window, cv2.WINDOW_AUTOSIZE)
        # cv2.resizeWindow(np_result_window, self.map_data.height, self.map_data.width)
        image = np_arr.view(np.uint8)
        cv2.imshow(np_result_window, image)
        cv2.waitKey()

    def callback_map(self, msg):
        print("callback_map")
        if self.data_loaded is not None:
            if not self.data_loaded:
                rospy.loginfo("[{}] Map received".format(rospy.get_caller_id()))
                arr = np.array(msg.data, dtype=np.int8)
                arr = arr.reshape((msg.info.height, msg.info.width))
                self.map_data = MapData(np_map=arr, map_msg=msg)

                self.np_show = self.map_data.np_unk
                self.map_data_publisher()
                self.map_poly_list_publisher()
                self.assemble_map()

    def map_show_publisher(self):
        if self.map_data is not None:
            map_msg = OccupancyGrid()
            map_msg.header.stamp = rospy.Time.now()
            map_msg.header.frame_id = "map"
            map_msg.info = self.map_data.initial_map.info
            map_msg.info.width = self.np_show.shape[1]
            map_msg.info.height = self.np_show.shape[0]
            np_arr = self.np_show.reshape((self.np_show.size,))
            map_msg.data = np_arr.tolist()
            self.map_show_pub.publish(map_msg)

    def map_assembled_publisher(self):
        if self.map_data is not None:
            map_msg = OccupancyGrid()
            map_msg.header.stamp = rospy.Time.now()
            map_msg.header.frame_id = "map"
            map_msg.info = self.map_data.initial_map.info
            map_msg.info.width = self.map_data.np_assembled.shape[1]
            map_msg.info.height = self.map_data.np_assembled.shape[0]
            np_arr = self.map_data.np_assembled.reshape((self.np_show.size,))
            map_msg.data = np_arr.tolist()
            self.map_assembled_pub.publish(map_msg)

    def map_edited_publisher(self):
        if self.map_data is not None:
            map_msg = OccupancyGrid()
            map_msg.header.stamp = rospy.Time.now()
            map_msg.header.frame_id = "map"
            map_msg.info = self.map_data.initial_map.info
            map_msg.info.width = self.map_data.np_assembled.shape[1]
            map_msg.info.height = self.map_data.np_assembled.shape[0]
            np_arr = self.map_data.np_semi_assembled.reshape((self.np_show.size,))
            map_msg.data = np_arr.tolist()
            self.map_edited_pub.publish(map_msg)



    def assemble_map(self):
        self.map_data.clear_layers()
        self.draw_map_polygons()
        # Create basic map layers (unk, free, occupied)
        self.map_data.np_unk = np.where(self.map_data.np_original == MapSpec.UNKNOWN, MapSpec.OBSTACLE, self.map_data.np_unk)
        self.map_data.np_occupied = np.where(self.map_data.np_original == MapSpec.OBSTACLE, MapSpec.OBSTACLE, self.map_data.np_occupied)
        self.map_data.np_free = np.where(self.map_data.np_original == MapSpec.FREE, MapSpec.FREE, self.map_data.np_free)

        # Remove unknown noise
        shape_size = self.map_data.fill_hole_px
        kernel = cv2.getStructuringElement(self.map_data.fill_shape_cv,
                                           (2 * shape_size + 1, 2 * shape_size + 1),
                                           (shape_size, shape_size))
        self.map_data.np_unk_cleaned = cv2.dilate(self.map_data.np_unk.view(np.uint8), kernel, iterations=1)
        shape_size = self.map_data.fill_hole_px + 2
        kernel = cv2.getStructuringElement(self.map_data.fill_shape_cv,
                                           (2 * shape_size + 1, 2 * shape_size + 1),
                                           (shape_size, shape_size))
        self.map_data.np_unk_cleaned = cv2.erode(self.map_data.np_unk_cleaned, kernel, iterations=1)
        self.map_data.np_unk_cleaned = self.map_data.np_unk_cleaned.view(np.int8)


        # Unknown as obstacle
        self.map_data.np_occupied = np.where(self.map_data.np_unk_cleaned == MapSpec.OBSTACLE, self.map_data.np_unk_cleaned, self.map_data.np_occupied)

        # Fill holes in free
        shape_size = self.map_data.fill_hole_px
        kernel = cv2.getStructuringElement(self.map_data.fill_shape_cv,
                                           (2 * shape_size + 1, 2 * shape_size + 1),
                                           (shape_size, shape_size))
        self.map_data.np_free_filled = cv2.erode(self.map_data.np_free.view(np.uint8), kernel, iterations=1)
        self.map_data.np_free_filled = self.map_data.np_free_filled.view(np.int8)

        # Semi assembled map
        self.map_data.np_semi_assembled = np.where(self.map_data.np_free_filled == MapSpec.FREE, MapSpec.FREE, self.map_data.np_semi_assembled)
        self.map_data.np_semi_assembled = np.where(self.map_data.np_occupied == MapSpec.OBSTACLE, MapSpec.OBSTACLE, self.map_data.np_semi_assembled)
        self.map_data.np_semi_assembled = np.where(self.map_data.np_poly_free == MapSpec.FREE, MapSpec.FREE, self.map_data.np_semi_assembled)
        self.map_data.np_semi_assembled = np.where(self.map_data.np_poly_obstacle == MapSpec.OBSTACLE, MapSpec.OBSTACLE, self.map_data.np_semi_assembled)

        # Obstacle margin
        shape_size = self.map_data.obstacle_margin_px
        kernel = cv2.getStructuringElement(self.map_data.fill_shape_cv,
                                           (2 * shape_size + 1, 2 * shape_size + 1),
                                           (shape_size, shape_size))
        self.map_data.np_obstacle_margin = cv2.dilate(self.map_data.np_semi_assembled.view(np.uint8), kernel, iterations=1)
        self.map_data.np_obstacle_margin = self.map_data.np_obstacle_margin.view(np.int8)

        # Assemble map
        self.map_data.np_assembled = np.where(self.map_data.np_obstacle_margin == MapSpec.OBSTACLE, MapSpec.OBSTACLE, self.map_data.np_semi_assembled)

        # Show map
        self.np_show = self.map_data.np_assembled
        self.log_publisher("Map Assembled.")
        rospy.loginfo("[{}] Map assembled.".format(rospy.get_caller_id()))

    def callback_map_assemble(self, msg):
        self.map_data.obstacle_margin = msg.margin
        self.map_data.obstacle_margin_px = int(round(msg.margin / self.map_data.resolution))
        self.map_data.fill_hole_px = msg.fill
        self.map_data.fill_shape = msg.shape
        if msg.shape == 'ellipse':
            self.map_data.fill_shape_cv = cv2.MORPH_ELLIPSE
        if msg.shape == 'square':
            self.map_data.fill_shape_cv = cv2.MORPH_RECT
        self.assemble_map()
        self.map_data_publisher()
        self.map_zone_list_publisher()
        self.program_list_publisher()
        self.save_running_data()

    def map_data_publisher(self):
        msg = MapEditMap()
        msg.header.stamp = rospy.Time.now()
        msg.name = self.map_data.name
        msg.fill = self.map_data.fill_hole_px
        msg.margin = self.map_data.obstacle_margin
        msg.shape = self.map_data.fill_shape
        self.map_data_pub.publish(msg)

    def callback_show_map_layer(self, msg):
        rospy.loginfo("[{}] Show map layer: {}".format(rospy.get_caller_id(), msg.data))
        if msg.data == "filled":
            self.np_show = self.map_data.np_free_filled
        elif msg.data == "obstacle_margin":
            self.np_show = self.map_data.np_obstacle_margin
        elif msg.data == "obstacles_poly":
            self.np_show = self.map_data.np_poly_obstacle
        elif msg.data == "free_poly":
            self.np_show = self.map_data.np_poly_free
        elif msg.data == "assembled_lite":
            self.np_show = self.map_data.np_semi_assembled
        elif msg.data == "original":
            self.np_show = self.map_data.np_original
        elif msg.data == "assembled":
            self.np_show = self.map_data.np_assembled
        elif msg.data == "zone_map":
            if self.current_zone is not None:
                self.np_show = self.current_zone.np_zone
        elif msg.data == "zone_border_path":
            if self.current_zone is not None:
                self.np_show = self.current_zone.np_zone_paths
        elif msg.data == "zone_navi":
            if self.current_zone is not None:
                self.np_show = self.current_zone.np_zone_navi

    def callback_map_save_poly(self, msg):
        # Add or overwrite polygon
        poly_exist = False
        poly_exist_id = -1
        i = 0
        for p_msg in self.map_data.polygon_msgs:
            if p_msg.name == msg.name:
                poly_exist = True
                poly_exist_id = i
            i += 1
        if not poly_exist:
            self.map_data.polygon_msgs.append(msg)
        else:
            self.map_data.polygon_msgs[poly_exist_id] = msg
        self.map_poly_list_publisher()
        self.assemble_map()
        self.log_publisher("Polygon {} {} saved.".format(msg.type, msg.name))  # Show map
        self.np_show = self.map_data.np_semi_assembled
        # self.cv_show(self.map_data.np_assembled)
        self.save_running_data()

    def draw_map_polygons(self):
        # Draw polygons to layers
        for p_msg in self.map_data.polygon_msgs:
            polygon = []
            for point in p_msg.polygon.polygon.points:
                x_point = int(point.x / self.map_data.resolution)
                y_point = int(point.y / self.map_data.resolution)
                polygon.append([self.map_data.x_origin + x_point, self.map_data.y_origin + y_point])
            np_polygon = np.array(polygon)
            if p_msg.type == 'obstacle':
                cv2.fillPoly(self.map_data.np_poly_obstacle, pts=[np_polygon], color=MapSpec.OBSTACLE)
            if p_msg.type == 'free':
                cv2.fillPoly(self.map_data.np_poly_free, pts=[np_polygon], color=MapSpec.FREE)

    def callback_map_remove_poly(self, msg):
        # Remove polygon
        for p_msg in self.map_data.polygon_msgs:
            if p_msg.name == msg.data:
                self.map_data.polygon_msgs.remove(p_msg)
        self.map_poly_list_publisher()
        self.assemble_map()
        self.log_publisher("Polygon {} removed.".format(msg.data))
        # Show map
        self.np_show = self.map_data.np_semi_assembled

    def map_poly_list_publisher(self):
        msg = MapEditPolygonList()
        msg.header.stamp = rospy.Time.now()
        msg.header.frame_id = "map"
        msg.polygon_list = []
        for poly_msg in self.map_data.polygon_msgs:
            msg.polygon_list.append(poly_msg)
        self.map_poly_list_pub.publish(msg)

    def callback_map_save_zone(self, msg):
        polygon = []
        for point in msg.polygon.polygon.points:
            x_point = int(point.x / self.map_data.resolution)
            y_point = int(point.y / self.map_data.resolution)
            polygon.append([self.map_data.x_origin + x_point, self.map_data.y_origin + y_point])
        np_polygon = np.array(polygon)

        # make zone polygon smaller by cut coverage radius
        shape_poly = geometry.Polygon(np_polygon)
        cut_margin_dist = int(round((MapSpec.COVERAGE_DIAMETER / 2) / self.map_data.resolution))
        shape_poly = shape_poly.buffer(-cut_margin_dist)
        pointarray = []
        for point in shape_poly.exterior.coords:
            pointarray.append([int(point[0]), int(point[1])])
        np_polygon_mow = np.array(pointarray)

        # draw polygon on zone layer
        np_zone = np.zeros_like(self.map_data.np_assembled)
        cv2.fillPoly(np_zone, pts=[np_polygon_mow], color=MapSpec.OBSTACLE)
        np_zone = np.where(np_zone == MapSpec.OBSTACLE, self.map_data.np_assembled, MapSpec.OBSTACLE)

        # make zone polygon bigger by obstacle margin and draw zone map for navi
        shape_poly = geometry.Polygon(np_polygon)
        shape_poly = shape_poly.buffer(self.map_data.obstacle_margin_px, cap_style='flat', join_style='mitre')
        pointarray = []
        for point in shape_poly.exterior.coords:
            pointarray.append([int(point[0]), int(point[1])])
        np_polygon_navi = np.array(pointarray)

        # draw polygon on navi zone layer
        np_zone_navi = np.zeros_like(self.map_data.np_assembled)
        cv2.fillPoly(np_zone_navi, pts=[np_polygon_navi], color=MapSpec.OBSTACLE)
        np_zone_navi = np.where(np_zone_navi == MapSpec.OBSTACLE, self.map_data.np_semi_assembled, MapSpec.OBSTACLE)
        zone = Zone(np_zone, np_zone_navi, msg)

        # Create paths around zone and coverage paths
        self.current_zone = zone
        self.create_paths_around()
        self.current_zone.msg.paths = []
        # self.create_outline_path_msg()
        self.create_coverage_paths()
        self.create_coverage_path_msg()



        # Save or update current zone
        zone_exist = False
        zone_exist_id = -1
        i = 0
        for z in self.map_data.zones:
            if z.msg.name == msg.name:
                zone_exist = True
                zone_exist_id = i
            i += 1
        if not zone_exist:
            self.map_data.zones.append(self.current_zone)
        else:
            self.map_data.zones[zone_exist_id] = self.current_zone

        self.map_zone_list_publisher()
        self.create_program()  # Need add program creating in webui
        self.program_list_publisher()
        # Show zone map
        self.np_show = self.current_zone.np_zone_paths
        self.create_zone_path_marker_array()
        self.log_publisher("Zone {} saved.".format(self.current_zone.msg.name))
        self.save_running_data()

    def callback_zone_remove(self, msg):
        # Remove zone
        for zone in self.map_data.zones:
            if zone.msg.name == msg.data:
                self.map_data.zones.remove(zone)
        self.map_zone_list_publisher()
        self.create_program()
        self.program_list_publisher()
        # Show map
        self.np_show = self.map_data.np_assembled
        self.log_publisher("Zone {} removed.".format(msg.data))
        self.save_running_data()

    def callback_zone_selected(self, msg):
        if msg.data == "cancel**cancel**":
            self.np_show = self.map_data.np_assembled
            self.current_zone = None
        else:
            for zone in self.map_data.zones:
                if zone.msg.name == msg.data:
                    self.current_zone = zone
                    self.np_show = zone.np_zone
                    self.log_publisher("Zone {} selected.".format(msg.data))
                    break

    def map_zone_list_publisher(self):
        msg = MapEditZoneList()
        msg.header.stamp = rospy.Time.now()
        msg.header.frame_id = "map"
        msg.zone_list = []
        for zone in self.map_data.zones:
            msg.zone_list.append(zone.msg)
        self.zone_list_pub.publish(msg)

    def get_shapely_poly(self, polygons, contours, hierarchy, poly_id, external, internals):
        while poly_id != -1:
            contour = contours[poly_id].squeeze(axis=1)
            if len(contour) >= 3:
                first_child_id = hierarchy[poly_id][2]
                children = [] if external else None
                self.get_shapely_poly(polygons, contours, hierarchy, first_child_id, not external, children)
                if external:
                    polygon = geometry.Polygon(contour, holes=children)
                    polygons.append(polygon)
                else:
                    internals.append(contour)


            poly_id = hierarchy[poly_id][0]

    def create_paths_around(self):
        self.log_publisher("Creating outline paths...")
        image_copy = self.current_zone.np_zone_navi.copy()
        area_sum = 0
        for i in range(0, self.current_zone.msg.border_paths):
            print("i: {}".format(i))
            inverted = cv2.bitwise_not(self.current_zone.np_zone_paths.view(np.uint8))
            inverted = np.where(inverted == 255, inverted, 0)
            contours, hierarchy = cv2.findContours(inverted, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)
            if hierarchy is None:
                break
            polygons = []
            hierarchy = hierarchy[0]
            self.get_shapely_poly(polygons, contours, hierarchy, 0, True, [])
            for poly in polygons:
                ros_poly = self.convert_poly_to_ros_coord(poly)
                self.current_zone.path_polygons.append(PathPolygon(ros_poly, i))

                # Save area of the first path greater of 1/2 of the coverage diameter
                if i == 0:
                    mow_radius = MapSpec.COVERAGE_DIAMETER / 2
                    poly_b = ros_poly.buffer(mow_radius,
                                       join_style='round',
                                       mitre_limit=5.0,
                                       cap_style='flat',
                                       quad_segs=16)
                    area_sum += poly_b.area

                # Draw exterior to map
                points = [[x, y] for x, y in zip(*poly.exterior.coords.xy)]
                image_copy = cv2.polylines(image_copy, pts=np.array([points]).astype(np.int32),
                                           isClosed=True, color=90, thickness=1)

                for inner in poly.interiors:
                    # Draw interior holes to map
                    points = [[x, y] for x, y in zip(*inner.coords.xy)]
                    image_copy = cv2.polylines(image_copy, pts=np.array([points]).astype(np.int32),
                                               isClosed=True, color=120, thickness=1)

            # Obstacle margin
            shape_size = int(round(self.current_zone.msg.paths_distance / self.map_data.resolution))
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,
                                               (2 * shape_size + 1, 2 * shape_size + 1),
                                               (shape_size, shape_size))
            self.current_zone.np_zone_paths = cv2.dilate(self.current_zone.np_zone_paths.view(np.uint8), kernel, iterations=1)
            self.current_zone.np_zone_paths = self.current_zone.np_zone_paths.view(np.int8)
        self.current_zone.np_zone_paths = image_copy
        self.current_zone.msg.area = round(area_sum)

    def map_coord_to_ros_coord(self, points):
        output = []
        for point in points:
            point[0] = point[0] * self.map_data.resolution + self.map_data.origin_x
            point[1] = point[1] * self.map_data.resolution + self.map_data.origin_y
            output.append(point)
        return output


    def convert_poly_to_ros_coord(self, poly):
        points = [[x, y] for x, y in zip(*poly.exterior.coords.xy)]
        ext_coords = self.map_coord_to_ros_coord(points)
        holes = []
        for inner in poly.interiors:
            points2 = [[x, y] for x, y in zip(*inner.coords.xy)]
            in_coords = self.map_coord_to_ros_coord(points2)
            holes.append(in_coords)
        return geometry.Polygon(ext_coords, holes=holes)

    def marker_line_list_from_points(self, points, ns, id, color=None, scale=MapSpec.COVERAGE_DIAMETER):
        if color is None:
            color = [random.uniform(0.0, 1.0), random.uniform(0.0, 0.1), random.uniform(0.0, 0.1), 1.0]
        marker = Marker()
        marker.header.frame_id = "map"
        marker.header.stamp = rospy.Time.now()
        marker.ns = ns
        marker.type = Marker.LINE_LIST
        marker.id = id
        marker.scale.x = scale
        marker.scale.y = scale
        marker.scale.z = scale
        marker.color.r = color[0]
        marker.color.g = color[1]
        marker.color.b = color[2]
        marker.color.a = color[3]
        marker.pose.position.x = 0
        marker.pose.position.y = 0
        marker.pose.position.z = 0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.points = points
        return marker

    def marker_points_from_points(self, points, ns, id, color=None, scale=0.3):
        if color is None:
            color = [1, 0, 0, 1]
        marker = Marker()
        marker.header.frame_id = "map"
        marker.header.stamp = rospy.Time.now()
        marker.ns = ns
        marker.type = Marker.POINTS
        marker.id = id
        marker.scale.x = scale
        marker.scale.y = scale
        marker.scale.z = scale
        marker.color.r = color[0]
        marker.color.g = color[1]
        marker.color.b = color[2]
        marker.color.a = color[3]
        marker.pose.position.x = 0
        marker.pose.position.y = 0
        marker.pose.position.z = 0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.points = points
        return marker

    def zone_path_lines_publisher(self):
        if self.current_zone is not None:
            self.marker_zone_path_lines_pub.publish(self.current_zone.zone_path_lines_marker_array)

    def create_zone_path_marker_array(self):
        marker_array = MarkerArray()
        points = []
        start_points = []
        end_points = []
        zone = self.current_zone
        i = 0
        if zone is not None:
            for poly in zone.path_polygons:
                poly = poly.polygon.simplify(self.current_zone.msg.simplify, preserve_topology=True)
                line_start = None
                for point in shapely.get_coordinates(poly.exterior):
                    if line_start == None:
                        line_start = Point32(point[0], point[1], 0)
                    else:
                        points.append(line_start)
                        points.append(Point32(point[0], point[1], 0))
                        line_start = Point32(point[0], point[1], 0)
                start_points.append(points[0])
                # end_points.append(points[-1])
                marker = self.marker_line_list_from_points(points, "zone_outline_poly_{}".format(i), i, color=[0, 0, 1, 1], scale=0.05)
                marker_array.markers.append(marker)
                points = []
                i += 1
                for inner in poly.interiors:
                    line_start = None
                    for point in shapely.get_coordinates(inner):
                        if line_start == None:
                            line_start = Point32(point[0], point[1], 0)
                        else:
                            points.append(line_start)
                            points.append(Point32(point[0], point[1], 0))
                            line_start = Point32(point[0], point[1], 0)
                    start_points.append(points[0])
                    # end_points.append(points[-1])
                    marker = self.marker_line_list_from_points(points, "zone_outline_poly_{}".format(i), i, color=[0, 0, 1, 1], scale=0.05)
                    marker_array.markers.append(marker)
                    points = []
                    i += 1
            il = 0
            for multiline in self.current_zone.multilines:
                # print(len(multiline.geoms))
                for line in multiline.geoms:
                    points.append(Point32(line.coords[0][0], line.coords[0][1], 0))
                    points.append(Point32(line.coords[1][0], line.coords[1][1], 0))
                if len(points) > 0:
                    start_points.append(points[0])
                    end_points.append(points[-1])
                marker = self.marker_line_list_from_points(points, "zone_coverage_line_{}".format(il), i, color=None, scale=0.05)
                marker_array.markers.append(marker)
                points = []
                i += 1
                il += 1
        marker = self.marker_points_from_points(start_points, "start_points", i, color=[0, 1, 0, 0.5])
        marker_array.markers.insert(0, marker)
        i += 1
        marker = self.marker_points_from_points(end_points, "end_points", i, color=[1, 0, 0, 0.5])
        marker_array.markers.insert(0, marker)
        self.current_zone.zone_path_lines_marker_array = marker_array



    def zone_outline_poly_publisher(self):
        points = []
        zone = self.current_zone
        if zone is not None:
            for poly in zone.path_polygons:
                poly = poly.polygon.simplify(self.current_zone.msg.simplify, preserve_topology=True)
                line_start = None
                for point in shapely.get_coordinates(poly.exterior):
                    if line_start == None:
                        line_start = Point32(point[0], point[1], 0)
                    else:
                        points.append(line_start)
                        points.append(Point32(point[0], point[1], 0))
                        line_start = Point32(point[0], point[1], 0)
                for inner in poly.interiors:
                    line_start = None
                    for point in shapely.get_coordinates(inner):
                        if line_start == None:
                            line_start = Point32(point[0], point[1], 0)
                        else:
                            points.append(line_start)
                            points.append(Point32(point[0], point[1], 0))
                            line_start = Point32(point[0], point[1], 0)

        marker = Marker()
        marker.header.frame_id = "map"
        marker.header.stamp = rospy.Time.now()
        marker.ns = "zone_outline_polys"
        marker.type = Marker.LINE_LIST
        marker.id = 0
        marker.scale.x = 0.03
        marker.scale.y = 0.03
        marker.scale.z = 0.03
        marker.color.r = 0.0
        marker.color.g = 0.0
        marker.color.b = 1.0
        marker.color.a = 1.0
        marker.pose.position.x = 0
        marker.pose.position.y = 0
        marker.pose.position.z = 0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.points = points
        self.marker_pub.publish(marker)

    def get_top_level_outline_poly(self):
        polygons = []
        for poly in self.current_zone.path_polygons:
            if poly.path_level == self.current_zone.msg.border_paths - 1:
                polygons.append(poly.polygon)
        return polygons

    def filter_polygons(self, min_length=0.6, min_area=0.16):
        polygons = []
        for poly in self.current_zone.path_polygons:
            if poly.polygon.length > min_length and poly.polygon.area > min_area:
                polygons.append(poly.polygon)
        return polygons

    def get_polygons_ordered_by_start(self):
        distance = 99999999
        int_polygons = []
        ext_polygons = []
        out_polygons = []
        for polygon in self.filter_polygons():
            ext_polygons.append(polygon.exterior)
            if polygon.interiors:
                for in_poly in polygon.interiors:
                    int_polygons.append(in_poly)

        # Outlines
        prev_pol = ext_polygons.pop(0)
        id_n = 0
        out_polygons.append(prev_pol)
        while True:
            nearest_pol = None
            n = 0
            id_n = 0
            for pol in ext_polygons:
                line = geometry.LineString([[prev_pol.coords[0][0], prev_pol.coords[0][1]], [pol.coords[0][0], pol.coords[0][1]]])
                if line.length < distance:
                    nearest_pol = pol
                    id_n = n
                n += 1
            if nearest_pol is not None:
                prev_pol = ext_polygons.pop(id_n)
                out_polygons.append(prev_pol)
            else:
                break

        # Obstacles
        prev_pol = out_polygons[-1]
        id_n = 0
        # out_polygons.append(prev_pol)
        while True:
            nearest_pol = None
            n = 0
            id_n = 0
            for pol in int_polygons:
                line = geometry.LineString([[prev_pol.coords[0][0], prev_pol.coords[0][1]],
                                            [pol.coords[0][0], pol.coords[0][1]]])
                if line.length < distance:
                    nearest_pol = pol
                    id_n = n
                n += 1
            if nearest_pol is not None:
                prev_pol = int_polygons.pop(id_n)
                out_polygons.append(prev_pol)
            else:
                break
        return out_polygons

    def filter_list_of_polygons(self, polygons_in, min_length=0.8, min_area=0.3):
        polygons = []
        for poly in polygons_in:
            if poly.length > min_length and poly.area > min_area:
                polygons.append(poly)
        return polygons

    def create_coverage_paths(self):
        self.log_publisher("Creating coverage paths...")
        # Prepare outline polygons
        top_level_polygons = self.get_top_level_outline_poly()
        top_level_polygons = self.filter_list_of_polygons(top_level_polygons)

        multilines = []
        angle = self.current_zone.msg.coverage_angle
        paths_distance = self.current_zone.msg.paths_distance
        for polygon in top_level_polygons:
            max_length = 0.5 + shapely.distance(geometry.Point(polygon.bounds[0], polygon.bounds[1]),
                                                geometry.Point(polygon.bounds[2], polygon.bounds[3]))

            # Create lines for coverage
            start = geometry.Point(polygon.bounds[0], polygon.bounds[1], 0.0)
            end = geometry.Point(start.x + max_length, start.y, 0.0)
            line_list = []
            line_count = int(max_length / paths_distance)
            for n in range(0, line_count):
                line = geometry.LineString([start, end])
                line_list.append(line)
                start = geometry.Point(start.x, start.y + paths_distance, 0.0)
                end = geometry.Point(end.x, end.y + paths_distance, 0.0)
            multiline = geometry.MultiLineString(line_list)

            # center with border polygon
            move_x = polygon.centroid.x - multiline.centroid.x
            move_y = polygon.centroid.y - multiline.centroid.y
            multiline = affinity.translate(multiline, xoff=move_x, yoff=move_y, zoff=0)

            # rotate lines
            multiline = affinity.rotate(multiline, angle, origin="center", use_radians=False)

            # cut lines to fit the polygon outer border
            multiline = shapely.ops.split(multiline, polygon.buffer(-0.1))

            # remove lines out of the zone
            line_list = []
            for line in multiline.geoms:
                if shapely.contains_properly(polygon, line):
                    line_list.append(line)
            multiline = geometry.MultiLineString(line_list)

            # Remove short lines
            line_list = []
            for line in multiline.geoms:
                if line.length > 0.15:
                    line_list.append(line)
            multiline = geometry.MultiLineString(line_list)

            # connect lines by nearest point of other lines
            line_list = []
            for line in multiline.geoms:
                line_list.append([[line.coords[0][0], line.coords[0][1]],
                                  [line.coords[1][0], line.coords[1][1]]])
            np_lines = np.array(line_list)
            line_list = []
            # x = polygon.bounds[0]
            print("polygon.bounds: {}".format(polygon.bounds))
            x = polygon.bounds[0] - 1000
            y = polygon.bounds[3] + 1000
            point = geometry.Point(x, y)
            print("point: {}".format(point))
            i_all = 0
            # multilines = []
            direction = True  # True: forward, False: backward
            dir_last = None  # True: forward, False: backward
            while True:
                nearest_line = None
                distance = 9999999
                ni = 0
                i_line = 0
                # Find the nearest line from point
                for line in np_lines:
                    begin_point = geometry.Point([line[0][0], line[0][1]])
                    end_point = geometry.Point([line[1][0], line[1][1]])
                    if begin_point.distance(point) < distance:
                        distance = begin_point.distance(point)
                        nearest_line = line
                        direction = True
                        i_line = ni
                    if end_point.distance(point) < distance:
                        distance = end_point.distance(point)
                        nearest_line = [line[1], line[0]]  # reverse line
                        direction = False
                        i_line = ni
                    ni = ni + 1
                if nearest_line is not None:  # if any nearest line available
                    conn_line = geometry.LineString(
                        [[point.x, point.y], [nearest_line[0][0], nearest_line[0][1]]])
                    print(conn_line)
                    is_cross = self.is_crossing_polygon(conn_line, polygon)
                    if not is_cross:  # if the line is not crossing polygon check other lines
                        is_cross = self.is_crossing_other_lines(conn_line, multilines.copy(), geometry.MultiLineString(line_list))
                    if not is_cross:  # if the line is not crossing, connect
                        line_list.append(conn_line)
                        line_list.append(geometry.LineString(nearest_line))
                    else:  # if the line is crossing, close cell
                        if len(line_list) != 0:
                            # print("Error: line_list is empty.")
                            multilines.append(geometry.MultiLineString(line_list))
                        line_list = []
                        line_list.append(geometry.LineString(nearest_line))

                    point = geometry.Point([nearest_line[1][0], nearest_line[1][1]])
                    np_lines = np.delete(np_lines, [i_line], 0)
                    dir_last = direction
                    i_all = i_all + 1

                else:
                    break
            multilines.append(geometry.MultiLineString(line_list))
            # multilines += multilines
        self.current_zone.multilines = multilines
        # self.current_zone.multilines = self.interconnect_multilines()
        # self.create_coverage_path_msg()
        # self.create_outline_path_msg()

        # Draw multilines to map
        for multiline in multilines:
            self.current_zone.np_zone_paths = self.draw_multilines(multiline, self.current_zone.np_zone_paths)

    def connect_near_multilines(self):
        multilines = self.current_zone.multilines.copy()
        multilines_new = []
        multiline_new = []
        print("Begin connect near multilines")
        print("Multilines: {}".format(len(multilines)))
        for multiline in multilines:
            print("Multiline: {}".format(len(multiline.geoms)))
            previous_line = None
            last_line_to_connect = None
            last_line_to_start = None
            for line in multiline.geoms:
                if previous_line is not None:
                    line_begin = line.coords[0]
                    angle = round(self.direction(line.coords), 4)
                    previous_angle = round(self.direction(previous_line.coords), 4)
                    previous_line_end = geometry.Point(previous_line.coords[-1][0], previous_line.coords[-1][1])
                    distance = previous_line_end.distance(geometry.Point(line_begin[0], line_begin[1]))
                    print("#################")
                    print("Distance: {}".format(distance))
                    print("Angle: {}".format(angle))
                    print("End angle: {}".format(previous_angle))
                    if distance == 0 and previous_angle == angle:
                        print("Connect lines")
                        last_line_to_connect = line
                        if last_line_to_start is None:
                            last_line_to_start = previous_line
                        previous_line = line
                    else:
                        print("Not connect lines")
                        if last_line_to_connect is not None:
                            connected_line = geometry.LineString([[last_line_to_start.coords[0][0], last_line_to_start.coords[0][1]],
                                                                  [last_line_to_connect.coords[-1][0], last_line_to_connect.coords[-1][1]]])
                            last_line_to_connect = None
                            last_line_to_start = None
                            multiline_new.append(connected_line)
                        else:
                            multiline_new.append(previous_line)
                        previous_line = line
                else:
                    print("Previous_line is None")
                    previous_line = line
            if last_line_to_connect is not None:
                connected_line = geometry.LineString([[last_line_to_start.coords[0][0], last_line_to_start.coords[0][1]],
                                                      [last_line_to_connect.coords[-1][0], last_line_to_connect.coords[-1][1]]])
                multiline_new.append(connected_line)
            else:
                multiline_new.append(previous_line)

            multiline_new = [linec for linec in multiline_new]
            multilines_new.append(geometry.MultiLineString(multiline_new))
            multiline_new = []


        return multilines_new

    def create_coverage_path_msg(self):


        # Create path from coverage lines
        path_all = Path()
        path_all.header.frame_id = "map"
        path_all.header.stamp = rospy.Time.now()

        # for multiline in self.current_zone.multilines:
        for multiline in self.connect_near_multilines():
            path = Path()
            path.header.frame_id = "map"
            path.header.stamp = rospy.Time.now()
            end_point = None
            for line in multiline.geoms:
                # path = Path()
                # path.header.frame_id = "map"
                # path.header.stamp = rospy.Time.now()
                angle = self.direction(line.coords)
                line = line.segmentize(0.05)
                for point in line.coords:
                    pose = PoseStamped()
                    pose.header.frame_id = "map"
                    pose.header.stamp = rospy.Time.now()
                    pose.pose.position.x = point[0]
                    pose.pose.position.y = point[1]
                    pose.pose.position.z = 0.0
                    pose.pose.orientation = Quaternion(
                        *(kdl.Rotation.RPY(0, 0, angle).GetQuaternion()))
                    path.poses.append(pose)
                    path_all.poses.append(pose)
                    end_point = point
                # self.current_zone.msg.paths.append(path)
            self.current_zone.msg.paths.append(path)
        self.current_zone.path_msg_coverage = path_all

    def create_outline_path_msg(self):
        # Create path from coverage lines
        path_all = Path()
        path_all.header.frame_id = "map"
        path_all.header.stamp = rospy.Time.now()
        begin = True
        last_point = []
        for polygon in self.get_polygons_ordered_by_start():
            path = Path()
            path.header.frame_id = "map"
            path.header.stamp = rospy.Time.now()
            polygon = polygon.simplify(self.current_zone.msg.simplify)
            polygon = polygon.segmentize(0.05)
            n = 0
            if not begin:
                line = geometry.LineString([[last_point[0], last_point[1]], [polygon.coords[n][0], polygon.coords[n][1]]])
                angle = self.direction(line.coords)

                for point in line.coords:
                    pose = PoseStamped()
                    pose.header.frame_id = "map"
                    pose.header.stamp = rospy.Time.now()
                    pose.pose.position.x = point[0]
                    pose.pose.position.y = point[1]
                    pose.pose.position.z = 0.0
                    pose.pose.orientation = Quaternion(
                        *(kdl.Rotation.RPY(0, 0, angle).GetQuaternion()))
                    path.poses.append(pose)
            for n in range(0, len(polygon.coords) -1):
                # if n == len(polygon.coords):
                #     line = geometry.LineString([[polygon.coords[n][0], polygon.coords[n][1]], [polygon.coords[-1][0], polygon.coords[-1][1]]])
                # else:
                #     line = geometry.LineString([[polygon.coords[n][0], polygon.coords[n][1]], [polygon.coords[n + 1][0], polygon.coords[n + 1][1]]])

                # path = Path()
                # path.header.frame_id = "map"
                # path.header.stamp = rospy.Time.now()

                line = geometry.LineString([[polygon.coords[n][0], polygon.coords[n][1]], [polygon.coords[n + 1][0], polygon.coords[n + 1][1]]])
                angle = self.direction(line.coords)
                # line = line.segmentize(0.3)
                for point in line.coords:
                    pose = PoseStamped()
                    pose.header.frame_id = "map"
                    pose.header.stamp = rospy.Time.now()
                    pose.pose.position.x = point[0]
                    pose.pose.position.y = point[1]
                    pose.pose.position.z = 0.0
                    pose.pose.orientation = Quaternion(
                        *(kdl.Rotation.RPY(0, 0, angle).GetQuaternion()))
                    path.poses.append(pose)
                    path_all.poses.append(pose)
                # self.current_zone.msg.paths.append(path)
            self.current_zone.msg.paths.append(path)
            begin = True
            last_point = [polygon.coords[n+1][0], polygon.coords[n+1][1]]
        self.current_zone.path_msg_outline = path_all

    def direction(self, line):
        # point_2.x - point_1.x, point_2.y - point_1.y)
        x = line[1][0] - line[0][0]
        y = line[1][1] - line[0][1]
        diagonal = math.sqrt(x ** 2 + y ** 2)
        if y < 0:
            if x >= 0:
                angle = math.asin(y / diagonal)
            else:
                angle = math.acos(x / diagonal) * -1
        else:
            if x >= 0:
                angle = math.asin(y / diagonal)
            else:
                angle = math.acos(x / diagonal)
        return angle

    def zone_coverage_path_msg_publisher(self):
        if self.current_zone is not None:
            self.coverage_path_pub.publish(self.current_zone.path_msg_coverage)

    def zone_outline_path_msg_publisher(self):
        if self.current_zone is not None:
            self.outline_path_pub.publish(self.current_zone.path_msg_outline)

    def get_nearest_multiline(self, multiline_in, buff):

        top_level_polygons = self.get_top_level_outline_poly()
        top_level_polygons = self.filter_list_of_polygons(top_level_polygons)

        def check_cross(start_point, end_point):
            is_cross = False
            connection_line = geometry.LineString(
                            [[start_point.x, start_point.y],
                             [end_point.x, end_point.y]])
            for polygon in top_level_polygons:
                if not is_cross:
                    is_cross = self.is_crossing_polygon(connection_line, polygon)
            if not is_cross:
                is_cross = self.is_crossing_other_multilines(connection_line, self.current_zone.multilines.copy())
            return is_cross

        # print("multiline_in: {}".format(multiline_in))
        multiline_in_start_point = geometry.Point(multiline_in.geoms[0].coords[0][0], multiline_in.geoms[0].coords[0][1])
        multiline_in_end_point = geometry.Point(multiline_in.geoms[-1].coords[1][0], multiline_in.geoms[-1].coords[1][1])
        d = 0
        d_id = 0
        distance = 9999999
        nearest_multiline = None
        connect_to_begin = None
        if len(buff) > 0:
            for multilin in buff:
                if len(multilin.geoms) > 0:
                    start_point = geometry.Point(multilin.geoms[0].coords[0][0], multilin.geoms[0].coords[0][1])
                    end_point = geometry.Point(multilin.geoms[-1].coords[1][0], multilin.geoms[-1].coords[1][1])

                    # Find the nearest multiline end or start from buff's multilines starts or ends
                    if multiline_in_start_point.distance(end_point) < distance:
                        if not check_cross(multiline_in_start_point, end_point):
                            distance = multiline_in_start_point.distance(end_point)
                            d_id = d
                            nearest_multiline = multilin
                            connect_to_begin = True

                    if multiline_in_start_point.distance(start_point) < distance:
                        if not check_cross(multiline_in_start_point, start_point):
                            distance = multiline_in_start_point.distance(start_point)
                            d_id = d
                            nearest_multiline = self.reverse_multiline(multilin)
                            connect_to_begin = True

                    if multiline_in_end_point.distance(end_point) < distance:
                        if not check_cross(multiline_in_end_point, end_point):
                            distance = multiline_in_end_point.distance(end_point)
                            d_id = d
                            nearest_multiline = self.reverse_multiline(multilin)
                            connect_to_begin = False

                    if multiline_in_end_point.distance(start_point) < distance:
                        if not check_cross(multiline_in_end_point, start_point):
                            distance = multiline_in_end_point.distance(start_point)
                            d_id = d
                            nearest_multiline = multilin
                            connect_to_begin = False
                d += 1
                print("distance: {}".format(distance))
        return nearest_multiline, connect_to_begin, d_id

    def interconnect_multilines(self):
        print("Interconnecting multilines...")
        buffer = self.current_zone.multilines.copy()
        connected_multilines = []
        new_multiline = []
        is_any_connectable = False
        multiline = None
        while True:
            print("Buffer len: {}".format(len(buffer)))
            if len(buffer) > 0:
                multiline = buffer.pop(0)
                nearest_multiline, connect_to_begin, d_id = self.get_nearest_multiline(multiline, buffer)
                if nearest_multiline is not None:
                    is_any_connectable = True
                    if connect_to_begin:
                        for line in nearest_multiline.geoms:
                            new_multiline.append(line)
                        new_multiline.append(geometry.LineString(
                                            [[nearest_multiline.geoms[-1].coords[1][0], nearest_multiline.geoms[-1].coords[1][1]],
                                             [multiline.geoms[0].coords[0][0], multiline.geoms[0].coords[0][1]]]))
                        for line in multiline.geoms:
                            new_multiline.append(line)
                    else:
                        for line in multiline.geoms:
                            new_multiline.append(line)
                        new_multiline.append(geometry.LineString(
                                            [[multiline.geoms[-1].coords[1][0], multiline.geoms[-1].coords[1][1]],
                                             [nearest_multiline.geoms[0].coords[0][0], nearest_multiline.geoms[0].coords[0][1]]]))
                        for line in nearest_multiline.geoms:
                            new_multiline.append(line)
                else:
                    if len(new_multiline) > 0:
                        connected_multilines.append(geometry.MultiLineString(new_multiline))
                        new_multiline = []

            else:
                if len(new_multiline) > 0:
                    connected_multilines.append(geometry.MultiLineString(new_multiline))
                    new_multiline = []
                else:
                    connected_multilines.append(geometry.MultiLineString(multiline))
                # if is_any_connectable:
                #     buffer = connected_multilines.copy()
                #     print("Recreated buffer!!!!!!!!!!!!!!!")
                #     connected_multilines = []
                #     is_any_connectable = False
                # else:
                #     break
                break
        return connected_multilines

    def reverse_multiline(self, multiline):
        line_list = []
        for line in multiline.geoms:
            line_list.append(geometry.LineString([[line.coords[1][0], line.coords[1][1]], [line.coords[0][0], line.coords[0][1]]]))
        line_list.reverse()
        return geometry.MultiLineString(line_list)

    def draw_multilines(self, multilines, np_coverage):
        # Draw multilines to map
        for line in multilines.geoms:
            points = [[self.map_data.x_origin + int(x / self.map_data.resolution),
                       self.map_data.y_origin + int(y / self.map_data.resolution)] for x, y in zip(*line.coords.xy)]
            np_coverage = cv2.polylines(np_coverage, pts=np.array([points]).astype(np.int32),
                                        isClosed=True, color=180, thickness=1)
        return np_coverage

    def draw_multilines_and_line(self, multilines, line_in,  np_coverage=None):
        if np_coverage is None:
            np_coverage = np.zeros_like(self.map_data.np_original)
        # Draw multilines to map
        for multiline in multilines:
            for line in multiline.geoms:
                points = [[self.map_data.x_origin + int(x / self.map_data.resolution),
                           self.map_data.y_origin + int(y / self.map_data.resolution)] for x, y in zip(*line.coords.xy)]
                np_coverage = cv2.polylines(np_coverage, pts=np.array([points]).astype(np.int32),
                                             isClosed=True, color=180, thickness=1)
            points = [[self.map_data.x_origin + int(x / self.map_data.resolution),
                       self.map_data.y_origin + int(y / self.map_data.resolution)] for x, y in
                      zip(*line_in.coords.xy)]
            np_coverage = cv2.polylines(np_coverage, pts=np.array([points]).astype(np.int32),
                                        isClosed=True, color=110, thickness=2)
        return np_coverage

    def save_running_data(self):
        try:
            with open(os.path.expanduser('~') + '/.vitulus/running/map_data.pkl', 'wb') as output:
                pickle.dump(self.map_data, output, pickle.HIGHEST_PROTOCOL)
                rospy.loginfo("[{}] Planner data saved.".format(rospy.get_caller_id()))
            return True
        except Exception as e:
            print(e)
            return False

    def load_running_data(self):
        try:
            with open(os.path.expanduser('~') + '/.vitulus/running/map_data.pkl', 'rb') as input:
                self.map_data = pickle.load(input)
                self.np_show = self.map_data.np_assembled
                self.map_data_publisher()
                self.map_poly_list_publisher()
                self.map_zone_list_publisher()
                self.program_list_publisher()
                self.log_publisher("Planner data loaded")
                rospy.loginfo("[{}] Planner data loaded.".format(rospy.get_caller_id()))
                self.map_sub.unregister()
            return True
        except Exception as e:
            print(e)
            return False


    def is_crossing_polygon(self, geom, polygon):
        result = False
        if not polygon.contains(geom):  # Zone polygon
            result = True
            return result
        return result

    def is_crossing_other_lines(self, conn_line, multilines, line_list=None):
        result = False
        if line_list is not None:
            multilines.append(line_list)
        for multiline in multilines:
            for line in multiline.geoms:
                # Exclude previous line for same point
                if line.coords[1][0] != conn_line.coords[0][0] and line.coords[1][1] != conn_line.coords[0][1]:
                    if line.intersects(conn_line):
                        result = True
                        return result
        return result

    def is_crossing_other_multilines(self, conn_line, multilines):
        result = False
        for multiline in multilines:
            sub_conn_line = shapely.ops.substring(conn_line, start_dist=0.00002, end_dist=-0.00001)
            if multiline.intersects(sub_conn_line):
                result = True
                return result
        return result

    def create_program(self):
        self.map_data.planner_program_list_msg = PlannerProgramList()
        self.map_data.planner_program_list_msg.header.frame_id = "map"
        self.map_data.planner_program_list_msg.header.stamp = rospy.Time.now()
        program = PlannerProgram()
        program.name = "Auto created"
        area = 0
        for zone in self.map_data.zones:
            program.zone_list.append(zone.msg)
            area += zone.msg.area
        program.area = area
        self.map_data.planner_program_list_msg.program_list.append(program)


    def callback_program_select(self, msg):
        if self.map_data.planner_program_list_msg is not None:
            for program_msg in self.map_data.planner_program_list_msg.program_list:
                if program_msg.name == msg.data:
                    self.program_active = program_msg
                    self.log_publisher("Program selected to run: {}".format(msg.data))
                    rospy.loginfo("[{}] Program selected to run: {}".format(rospy.get_caller_id(), msg.data))
                    self.program_active_pub.publish(self.program_active)
                    break

    def program_list_publisher(self):
        if self.map_data.planner_program_list_msg is not None:
            self.program_list_pub.publish(self.map_data.planner_program_list_msg)


    def log_publisher(self, log_txt):
        msg = String()
        msg.data = log_txt
        self.log_pub.publish(msg)

    def callback_map_reload(self, msg):
        self.map_data_publisher()
        self.map_poly_list_publisher()
        self.map_zone_list_publisher()
        self.program_list_publisher()

if __name__ == '__main__':
    try:
        rospy.init_node('vitulus_planner_node')
        rospy.loginfo("[{}] Initialising...".format(rospy.get_caller_id()))
        node = Node()
        r = rospy.Rate(1)  # Hz
        node.data_loaded = node.load_running_data()

        def signal_handler():
            rospy.signal_shutdown("end")
            sys.exit(0)
        signal.signal(signal.SIGINT, signal_handler)

        while not rospy.is_shutdown():
            node.map_show_publisher()
            node.map_assembled_publisher()
            node.map_edited_publisher()
            node.zone_outline_poly_publisher()
            node.zone_path_lines_publisher()
            node.zone_coverage_path_msg_publisher()
            node.zone_outline_path_msg_publisher()
            r.sleep()

    except rospy.ROSInterruptException:
        rospy.logerr("[{}] error.".format(rospy.get_caller_id()))
